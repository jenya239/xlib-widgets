module;
#include <X11/Xlib.h>
// Добавляем необходимые включения для FreeType
#include <ft2build.h>
#include FT_FREETYPE_H
#include <X11/Xft/Xft.h>
#include <string>
#include <memory>
#include <chrono>

export module ui.text_field;

import ui.widget;
import ui.event;
import ui.render_buffer;

export class TextField : public Widget {
private:
    std::string text;
    std::string placeholder;

    // Цвета
    unsigned long bgColor = 0xFFFFFF;        // Белый фон
    unsigned long textColor = 0x000000;      // Черный текст
    unsigned long placeholderColor = 0x888888; // Серый текст для плейсхолдера
    unsigned long borderColor = 0xCCCCCC;    // Серая рамка
    unsigned long focusBorderColor = 0x3399FF; // Синяя рамка при фокусе

    // Состояние
    bool hasFocus = false;
    bool isEditable = true;
    bool dirty = true;

    // Курсор
    size_t cursorPosition = 0;
    bool cursorVisible = true;
    std::chrono::steady_clock::time_point lastCursorBlink;
    int padding = 5; // Отступ от краев

    // Обработка нажатия клавиш
    void handleKeyPress(int keycode, char keyChar) {
        if (!isEditable) return;

        // Обработка специальных клавиш
        if (keycode == 22) { // BackSpace
            if (cursorPosition > 0) {
                text.erase(cursorPosition - 1, 1);
                cursorPosition--;
                dirty = true;
            }
        } else if (keycode == 119) { // Delete
            if (cursorPosition < text.length()) {
                text.erase(cursorPosition, 1);
                dirty = true;
            }
        } else if (keycode == 114) { // Left arrow
            if (cursorPosition > 0) {
                cursorPosition--;
                dirty = true;
            }
        } else if (keycode == 113) { // Right arrow
            if (cursorPosition < text.length()) {
                cursorPosition++;
                dirty = true;
            }
        } else if (keycode == 110) { // Home
            cursorPosition = 0;
            dirty = true;
        } else if (keycode == 115) { // End
            cursorPosition = text.length();
            dirty = true;
        } else if (keyChar >= 32 && keyChar <= 126) { // Printable ASCII
            text.insert(cursorPosition, 1, keyChar);
            cursorPosition++;
            dirty = true;
        }
    }

public:
    TextField(int x, int y, int width, int height, const std::string& placeholder = "")
        : Widget(x, y, width, height), placeholder(placeholder),
          lastCursorBlink(std::chrono::steady_clock::now()) {
        // Инициализация текстового поля
    }

    void handleEvent(const Event& event) override {
        if (event.getType() == Event::Type::MousePress) {
            int mouseX = event.getX();
            int mouseY = event.getY();

            // Проверяем, находится ли клик внутри виджета
            if (mouseX >= getX() && mouseX < getX() + getWidth() &&
                mouseY >= getY() && mouseY < getY() + getHeight()) {
                hasFocus = true;

                // Здесь можно добавить логику для установки позиции курсора
                // в зависимости от позиции клика

                dirty = true;
            } else {
                hasFocus = false;
                dirty = true;
            }
        } else if (event.getType() == Event::Type::KeyPress && hasFocus) {
            handleKeyPress(event.getKeycode(), event.getKeyChar());
        }
    }

    void update() override {
        // Обновление состояния курсора (мигание)
        auto now = std::chrono::steady_clock::now();
        if (hasFocus && std::chrono::duration_cast<std::chrono::milliseconds>(
                now - lastCursorBlink).count() > 500) {
            cursorVisible = !cursorVisible;
            lastCursorBlink = now;
            dirty = true;
        }
    }

    void render() override {
        if (!isVisible() || !dirty) return;

        // Получаем буфер для рисования
        RenderBuffer* buffer = getBuffer();
        if (!buffer) return;

        // Определяем цвет рамки в зависимости от фокуса
        unsigned long currentBorderColor = hasFocus ? focusBorderColor : borderColor;

        // Рисуем рамку и фон
        buffer->clear(bgColor);
        // Рисуем рамку (предполагается, что у RenderBuffer есть метод drawRect)
        // Если такого метода нет, нужно реализовать рисование рамки другим способом

        // Рисуем текст
        if (!text.empty()) {
            // Предполагается, что у RenderBuffer есть метод drawText
            // Если такого метода нет, нужно реализовать рисование текста другим способом
        } else if (!placeholder.empty()) {
            // Рисуем плейсхолдер, если текст пуст
        }

        // Рисуем курсор, если поле в фокусе и курсор видим
        if (hasFocus && cursorVisible) {
            int cursorX = padding;
            // Вычисляем позицию курсора в зависимости от текста
            // Предполагается, что у RenderBuffer есть метод drawLine
            // Если такого метода нет, нужно реализовать рисование линии другим способом
        }

        dirty = false;
    }

    // Геттеры и сеттеры
    const std::string& getText() const { return text; }

    void setText(const std::string& newText) {
        text = newText;
        cursorPosition = text.length();
        dirty = true;
    }

    void setPlaceholder(const std::string& newPlaceholder) {
        placeholder = newPlaceholder;
        dirty = true;
    }

    void setEditable(bool editable) {
        isEditable = editable;
    }

    bool isEditable() const {
        return isEditable;
    }

    bool isDirty() const {
        return dirty;
    }

    bool hasFocus() const {
        return hasFocus;
    }
};